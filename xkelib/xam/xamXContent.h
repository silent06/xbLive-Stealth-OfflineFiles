#ifndef __XAMEXT_XCONTENT_H
#define __XAMEXT_XCONTENT_H

#define XCONTENT_UNRESTRICTED_LICENSEE          ((ULONGLONG) 0xFFFFFFFFFFFFFFFFULL)
#define XCONTENT_LICENSE_FLAG_REQUIRE_ONLINE    0x00000001

// some flags for mounting CON/LIVE/PIRS using mountCon/XamContentOpenFile
#define XCONTENT_ANY_USER								0xFF
#define XCONTENT_PKGFLAG_KEEP_OPEN_ON_TITLE_TERMINATE 	0x00000001
#define XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE 	0x00000002
#define XCONTENT_FLAG_ATTRIBUTE_DEVICE					FILE_ATTRIBUTE_DEVICE
#define XCONTENT_OPENPKG_DONT_VERIFY_SIGNATURE 			0x00010000
#define XCONTENT_OPENPKG_COPY_EXISTING_HANDLE 			0x00020000
#define XCONTENT_FLAG_EXECUTE 							0x04000000

// some combined flags for often used operations
#define XCONTENT_MOUNT_FOR_READ_ONLY					(XCONTENT_FLAG_ATTRIBUTE_DEVICE|XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE)
#define XCONTENT_MOUNT_FOR_EXEC							(XCONTENT_FLAG_EXECUTE|XCONTENT_FLAG_ATTRIBUTE_DEVICE| \
														XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE| \
														XCONTENT_PKGFLAG_KEEP_OPEN_ON_TITLE_TERMINATE)

#pragma warning(push)
#pragma warning(disable:4005) // Get rid of the redefinition warning
#define XCONTENTTYPE_SAVEDGAME					0x00000001
#define XCONTENTTYPE_MARKETPLACE				0x00000002
#define XCONTENTTYPE_PUBLISHER					0x00000003
#define XCONTENTTYPE_IPTV_DVR					0x00001000
#define XCONTENTTYPE_INSTALLED_XBOX360TITLE		0x00004000
#define XCONTENTTYPE_XBOXTITLE					0x00005000
#define XCONTENTTYPE_SOCIALTITLE				0x00006000
#define XCONTENTTYPE_XBOX360TITLE				0x00007000
#define XCONTENTTYPE_SU_STORAGEPACK				0x00008000
#define XCONTENTTYPE_AVATAR_ASSET				0x00009000
#define XCONTENTTYPE_PROFILE					0x00010000
#define XCONTENTTYPE_ADDON						0x00020000
#define XCONTENTTYPE_THEMATICSKIN				0x00030000
#define XCONTENTTYPE_CACHE						0x00040000
#define XCONTENTTYPE_STORAGEDOWNLOAD			0x00050000
#define XCONTENTTYPE_XBOXSAVEDGAME				0x00060000
#define XCONTENTTYPE_XBOXDOWNLOAD				0x00070000
#define XCONTENTTYPE_GAMEDEMO					0x00080000
#define XCONTENTTYPE_VIDEO						0x00090000
#define XCONTENTTYPE_GAMETITLE					0x000A0000
#define XCONTENTTYPE_INSTALLER					0x000B0000
#define XCONTENTTYPE_GAMETRAILER				0x000C0000
#define XCONTENTTYPE_ARCADE						0x000D0000
#define XCONTENTTYPE_XNA						0x000E0000
#define XCONTENTTYPE_LICENSESTORE				0x000F0000
#define XCONTENTTYPE_MOVIE						0x00100000
#define XCONTENTTYPE_TV							0x00200000
#define XCONTENTTYPE_MUSICVIDEO					0x00300000
#define XCONTENTTYPE_PROMOTIONAL				0x00400000
#define XCONTENTTYPE_PODCASTVIDEO				0x00500000
#define XCONTENTTYPE_VIRALVIDEO					0x00600000

#define XCONTENTDEVICETYPE_NONE         ((XCONTENTDEVICETYPE)0x0)
#define XCONTENTDEVICETYPE_HDD          ((XCONTENTDEVICETYPE)0x1) // in the sdk
#define XCONTENTDEVICETYPE_MU           ((XCONTENTDEVICETYPE)0x2) // in the sdk
#define XCONTENTDEVICETYPE_SYSTEMMU     ((XCONTENTDEVICETYPE)0x3)
#define XCONTENTDEVICETYPE_ODD          ((XCONTENTDEVICETYPE)0x4) // in the sdk
#define XCONTENTDEVICETYPE_XFERCABLE	((XCONTENTDEVICETYPE)0x8)
#define XCONTENTDEVICETYPE_USBMASS      ((XCONTENTDEVICETYPE)0x10)

// This flag is OR'd into a device type if the device is unformatted
#define XCONTENTDEVICEFLAG_UNFORMATTED  ((XCONTENTDEVICETYPE)0x80000000)
// This flag can be supplied to XContentCreateDeviceEnumerator to enumerate
// USB mass storage devices
#define XCONTENTDEVICEFLAG_USBMASS      (0x40000000)
#define XCONTENTDEVICE_ALL				(0xFFFFFFFF)
#pragma warning(pop)

typedef enum { // LICENSEE_TYPE 
	LICENSEE_TYPE_WINDOWS_ID = 0x3, // not sure on this one (velocity)
	LICENSEE_TYPE_XUID = 0x9,
	LICENSEE_TYPE_USER_PRIVILEGES = 0xB000,
	LICENSEE_TYPE_HV_FLAGS = 0xC000,
	LICENSEE_TYPE_KEY_VAULT_PRIVILEGES = 0xD000,
	LICENSEE_TYPE_MEDIA_FLAGS = 0xE000,
	LICENSEE_TYPE_CONSOLE_ID = 0xF000,
};
typedef enum XCONTENT_VOLUME_TYPE {
	STFS_VOLUME = 0x0,
	SVOD_VOLUME = 0x1,
};

typedef enum _XCONTENT_SIGNATURE_TYPE {
	CONSOLE_SIGNED = 0x434F4E20,
	LIVE_SIGNED    = 0x4C495645,
	PIRS_SIGNED    = 0x50495253,
} XCONTENT_SIGNATURE_TYPE;

typedef enum _INSTALLER_METADATA_TYPE {
	INSTALLER_METADATA_UNDEFINED = 0,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_PACKAGE_DOWNLOAD = 0x50245044,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_SYSTEM_UPDATE = 0x50245355,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_CONTENT = 0x50245443,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_UPDATE = 0x50245455,
	INSTALLER_METADATA_TYPE_SYSTEM_UPDATE = 0x53555044,
	INSTALLER_METADATA_TYPE_TITLE_UPDATE = 0x54555044,
} INSTALLER_METADATA_TYPE;

typedef enum _XONLINECONTENT_RESUME_STATE {
	XONLINECONTENT_RESUME_STATE_FILE_HEADERS_NOT_READY = 0x46494C48,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER = 0x464F4C44,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER_ATTEMPT_2 = 0x464F4C32,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER_ATTEMPT_3 = 0x464F4C33,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER = 0x666F6C64,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_2 = 0x666F6C32,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_3 = 0x666F6C33,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_4 = 0x666F6C34,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_5 = 0x666F6C35,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_6 = 0x666F6C36,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_7 = 0x666F6C37,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_8 = 0x666F6C38,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_9 = 0x666F6C39,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_10 = 0x666F6C3A,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_11 = 0x666F6C3B,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_12 = 0x666F6C3C,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_13 = 0x666F6C3D,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_14 = 0x666F6C3E,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_15 = 0x666F6C3F,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_16 = 0x666F6C40,
}XONLINECONTENT_RESUME_STATE;



// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//
typedef struct _XCONTENT_SIGNATURE { 
	BYTE Signature[0x100]; // 0x0 sz:0x100
	BYTE Reserved[0x128]; // 0x100 sz:0x128
} XCONTENT_SIGNATURE, *PXCONTENT_SIGNATURE; // size 552
C_ASSERT(sizeof(XCONTENT_SIGNATURE) == 0x228);

typedef struct _LICENSEE_BITS {
	USHORT Type;
	USHORT DataHi;
	ULONG DataLo;
	//UINT64 Type : 16; // 0x0 bfo:0x48
	//UINT64 Data : 48; // 0x0 bfo:0x0
} LICENSEE_BITS, *PLICENSEE_BITS; // size 8
C_ASSERT(sizeof(LICENSEE_BITS) == 0x8);

typedef union _LICENSEE { 
	LICENSEE_BITS Bits; // 0x0 sz:0x8
	UINT64 AsULONGLONG; // 0x0 sz:0x8
} LICENSEE, *PLICENSEE; // size 8
C_ASSERT(sizeof(LICENSEE) == 0x8);

typedef struct _XCONTENT_LICENSE { 
	LICENSEE LicenseeId; // 0 16bits type, 48bits data
	DWORD LicenseBits; // 8
	DWORD LicenseFlags; // 12
} XCONTENT_LICENSE, *PXCONTENT_LICENSE; // 16
C_ASSERT(sizeof(XCONTENT_LICENSE) == 16);

#define XCONTENT_HEADER_LICENSES	0x10
typedef struct _XCONTENT_HEADER { 
	XCONTENT_SIGNATURE_TYPE SignatureType; // 0
	union { // 4 sz: 0x228
		XE_CONSOLE_SIGNATURE ConsoleSignature;
		XCONTENT_SIGNATURE   ContentSignature;
	} Signature;
	XCONTENT_LICENSE LicenseDescriptors[XCONTENT_HEADER_LICENSES]; // 556
	BYTE ContentId[20]; // 812
	DWORD SizeOfHeaders; // 832
} XCONTENT_HEADER, *PXCONTENT_HEADER; // 836
C_ASSERT(sizeof(XCONTENT_HEADER) == 836); // XCONTENT_METADATA normally follows directly after

typedef struct _STF_VOLUME_DESCRIPTOR { 
	BYTE DescriptorLength; // 0x0 sz:0x1
	BYTE Version; // 0x1 sz:0x1
	BYTE ReadOnlyFormat : 1; // 0x2 bfo:0x0
	BYTE RootActiveIndex : 1; // 0x2 bfo:0x1
	BYTE DirectoryOverallocated : 1; // 0x2 bfo:0x2
	BYTE DirectoryIndexBoundsValid : 1; // 0x2 bfo:0x3
	BYTE DirectoryAllocationBlocks0; // 0x3 sz:0x1
	BYTE DirectoryAllocationBlocks1; // 0x4 sz:0x1
	BYTE DirectoryFirstBlockNumber0; // 0x5 sz:0x1
	BYTE DirectoryFirstBlockNumber1; // 0x6 sz:0x1
	BYTE DirectoryFirstBlockNumber2; // 0x7 sz:0x1
	BYTE RootHash[0x14]; // 0x8 sz:0x14
	DWORD NumberOfTotalBlocks; // 0x1C sz:0x4
	DWORD NumberOfFreeBlocks; // 0x20 sz:0x4
} STF_VOLUME_DESCRIPTOR, *PSTF_VOLUME_DESCRIPTOR; // size 36
C_ASSERT(sizeof(STF_VOLUME_DESCRIPTOR) == 0x24);

typedef struct _SVOD_HASH_ENTRY { 
	BYTE Hash[0x14]; // 0x0 sz:0x14
} SVOD_HASH_ENTRY, *PSVOD_HASH_ENTRY; // size 20
C_ASSERT(sizeof(SVOD_HASH_ENTRY) == 0x14);

typedef struct _SVOD_DEVICE_FEATURES { 
	BYTE ShouldBeZeroForDownlevelClients : 1; // 0x0 bfo:0x7
	BYTE HasEnhancedGDFLayout : 1; // 0x0 bfo:0x6
	BYTE MustBeZeroForFutureUsage : 6; // 0x0 bfo:0x0
} SVOD_DEVICE_FEATURES, *PSVOD_DEVICE_FEATURES; // size 1
C_ASSERT(sizeof(SVOD_DEVICE_FEATURES) == 0x1);

typedef struct _SVOD_DEVICE_DESCRIPTOR { 
	BYTE DescriptorLength; // 0x0 sz:0x1
	BYTE BlockCacheElementCount; // 0x1 sz:0x1
	BYTE WorkerThreadProcessor; // 0x2 sz:0x1
	BYTE WorkerThreadPriority; // 0x3 sz:0x1
	SVOD_HASH_ENTRY FirstFragmentHashEntry; // 0x4 sz:0x14
	SVOD_DEVICE_FEATURES Features; // 0x18 sz:0x1
	BYTE NumberOfDataBlocks2; // 0x19 sz:0x1
	BYTE NumberOfDataBlocks1; // 0x1A sz:0x1
	BYTE NumberOfDataBlocks0; // 0x1B sz:0x1
	BYTE StartingDataBlock0; // 0x1C sz:0x1
	BYTE StartingDataBlock1; // 0x1D sz:0x1
	BYTE StartingDataBlock2; // 0x1E sz:0x1
	BYTE Reserved[0x5]; // 0x1F sz:0x5
} SVOD_DEVICE_DESCRIPTOR, *PSVOD_DEVICE_DESCRIPTOR; // size 36
C_ASSERT(sizeof(SVOD_DEVICE_DESCRIPTOR) == 0x24);

typedef struct _XCONTENT_METADATA_MEDIA_DATA { 
	BYTE SeriesId[0x10]; // 0x0 sz:0x10
	BYTE SeasonId[0x10]; // 0x10 sz:0x10
	WORD SeasonNumber; // 0x20 sz:0x2
	WORD EpisodeNumber; // 0x22 sz:0x2
} XCONTENT_METADATA_MEDIA_DATA, *PXCONTENT_METADATA_MEDIA_DATA; // size 36
C_ASSERT(sizeof(XCONTENT_METADATA_MEDIA_DATA) == 0x24);

typedef struct _XCONTENT_METADATA_AVATAR_ASSET_DATA { 
	DWORD SubCategory; // 0x0 sz:0x4
	DWORD Colorizable; // 0x4 sz:0x4
	BYTE AssetId[0x10]; // 0x8 sz:0x10
	BYTE SkeletonVersionMask; // 0x18 sz:0x1
	BYTE Reserved[0xB]; // 0x19 sz:0xB
} XCONTENT_METADATA_AVATAR_ASSET_DATA, *PXCONTENT_METADATA_AVATAR_ASSET_DATA; // size 36
C_ASSERT(sizeof(XCONTENT_METADATA_AVATAR_ASSET_DATA) == 0x24);

typedef struct _XCONTENT_ATTRIBUTES { 
	BYTE Reserved : 2; // 0x0 bfo:0x0
	BYTE DeepLinkSupported : 1; // 0x0 bfo:0x2
	BYTE DisableNetworkStorage : 1; // 0x0 bfo:0x3
	BYTE KinectEnabled : 1; // 0x0 bfo:0x4
	BYTE MoveOnlyTransfer : 1; // 0x0 bfo:0x5
	BYTE DeviceTransfer : 1; // 0x0 bfo:0x6
	BYTE ProfileTransfer : 1; // 0x0 bfo:0x7
} XCONTENT_ATTRIBUTES, *PXCONTENT_ATTRIBUTES; // size 1
C_ASSERT(sizeof(XCONTENT_ATTRIBUTES) == 0x1);

typedef union _XCONTENT_METADATA_FLAGS { 
	XCONTENT_ATTRIBUTES Bits; // 0x0 sz:0x1
	BYTE FlagsAsBYTE; // 0x0 sz:0x1
} XCONTENT_METADATA_FLAGS, *PXCONTENT_METADATA_FLAGS; // size 1
C_ASSERT(sizeof(XCONTENT_METADATA_FLAGS) == 0x1);

typedef struct _XCONTENT_METADATA { 
	DWORD ContentType; // 0x0 sz:0x4
	DWORD ContentMetadataVersion; // 0x4 sz:0x4
	LARGE_INTEGER ContentSize; // 0x8 sz:0x8
	XEX_EXECUTION_ID ExecutionId; // 0x10 sz:0x18
	BYTE ConsoleId[0x5]; // 0x28 sz:0x5
	QWORD Creator; // 0x2D sz:0x8
	union {
		STF_VOLUME_DESCRIPTOR StfsVolumeDescriptor; // 0x35 sz:0x24
		SVOD_DEVICE_DESCRIPTOR SvodVolumeDescriptor; // 0x35 sz:0x24
	};
	DWORD DataFiles; // 0x59 sz:0x4
	QWORD DataFilesSize; // 0x5D sz:0x8
	enum XCONTENT_VOLUME_TYPE VolumeType; // 0x65 sz:0x4
	QWORD OnlineCreator; // 0x69 sz:0x8
	DWORD Category; // 0x71 sz:0x4
	BYTE Reserved2[0x20]; // 0x75 sz:0x20
	union {
		XCONTENT_METADATA_MEDIA_DATA MediaData; // 0x95 sz:0x24
		XCONTENT_METADATA_AVATAR_ASSET_DATA AvatarAssetData; // 0x95 sz:0x24
	};
	BYTE DeviceId[0x14]; // 0xB9 sz:0x14
	WCHAR DisplayName[0x9][0x80]; // 0xCD sz:0x900
	WCHAR Description[0x9][0x80]; // 0x9CD sz:0x900
	WCHAR Publisher[0x40]; // 0x12CD sz:0x80
	WCHAR TitleName[0x40]; // 0x134D sz:0x80
	XCONTENT_METADATA_FLAGS Flags; // 0x13CD sz:0x1
	DWORD ThumbnailSize; // 0x13CE sz:0x4
	DWORD TitleThumbnailSize; // 0x13D2 sz:0x4
	BYTE Thumbnail[0x3D00]; // 0x13D6 sz:0x3D00
	WCHAR DisplayNameEx[3][0x80]; // 0x50D6 sz:0x300
	BYTE TitleThumbnail[0x3D00]; // 0x53D6 sz:0x3D00
	WCHAR DescriptionEx[3][0x80]; // 0x90D6 sz:0x300
} XCONTENT_METADATA, *PXCONTENT_METADATA; // size 37846
C_ASSERT(sizeof(XCONTENT_METADATA) == 0x93D6);

typedef struct _XCONTENT_METADATA_INSTALLER_TITLE_UPDATE { 
	DWORD CurrentVersion; // 0x0 sz:0x4
	DWORD NewVersion; // 0x4 sz:0x4
	BYTE Reserved[0x15E8]; // 0x8 sz:0x15E8
} XCONTENT_METADATA_INSTALLER_TITLE_UPDATE, *PXCONTENT_METADATA_INSTALLER_TITLE_UPDATE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_TITLE_UPDATE) == 0x15F0);

typedef struct _XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE { 
	DWORD SystemVersion; // 0x0 sz:0x4
	DWORD NewVersion; // 0x4 sz:0x4
	BYTE Reserved[0x15E8]; // 0x8 sz:0x15E8
} XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE, *PXCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE) == 0x15F0);

typedef struct _XONLINECONTENT_RESUME_HEADER { 
	XONLINECONTENT_RESUME_STATE ResumeState; // 0x0 sz:0x4
	DWORD dwCurrentFileIndex; // 0x4 sz:0x4
	LARGE_INTEGER liCurrentFileOffset; // 0x8 sz:0x8
	LARGE_INTEGER liBytesProcessed; // 0x10 sz:0x8
	LARGE_INTEGER liLastModified; // 0x18 sz:0x8
} XONLINECONTENT_RESUME_HEADER, *PXONLINECONTENT_RESUME_HEADER; // size 32
C_ASSERT(sizeof(XONLINECONTENT_RESUME_HEADER) == 0x20);

typedef struct _XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE { 
	struct _XONLINECONTENT_RESUME_HEADER ResumeHeader; // 0x0 sz:0x20
	BYTE CabResumeData[0x15D0]; // 0x20 sz:0x15D0
} XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE, *PXCONTENT_METADATA_INSTALLER_PROGRESS_CACHE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE) == 0x15F0);

typedef struct _XCONTENT_METADATA_INSTALLER { 
	INSTALLER_METADATA_TYPE MetaDataType; // 0x0 sz:0x4
	union {
		XCONTENT_METADATA_INSTALLER_TITLE_UPDATE TitleUpdate;
		XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE SystemUpdate;
		XONLINECONTENT_RESUME_HEADER ResumeHeader;
	}MetaData; // 0x4 sz:0x15F0
} XCONTENT_METADATA_INSTALLER, *PXCONTENT_METADATA_INSTALLER; // size 5620
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER) == 0x15F4);

// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//

typedef struct _XCONTENT_MOUNTED_PACKAGE { 
	PVOID pvFsDeviceObject; // 0x0 sz:0x4
	PVOID pvFsBlockCache; // 0x4 sz:0x4
	LIST_ENTRY leMountedPackages; // 0x8 sz:0x8
	DWORD dwFlags; // 0x10 sz:0x4
	HANDLE hPackageFile; // 0x14 sz:0x4
	DWORD dwOpenRefCount; // 0x18 sz:0x4
	RTL_CRITICAL_SECTION csHeaderLock; // 0x1C sz:0x1C
	XCONTENT_HEADER ContentHeader; // 0x38 sz:0x344
	XCONTENT_METADATA ContentMetaData; // 0x37C sz:0x93D6
	PBYTE pbOtherMetaData; // 0x9754 sz:0x4
	DWORD dwOtherMetaDataSize; // 0x9758 sz:0x4
	DWORD DeviceIDLocked; // 0x975C sz:0x4
	char szFsDeviceName[0x40]; // 0x9760 sz:0x40
	char szPackageFilePath[MAX_PATH]; // 0x97A0 sz:0x104
	DWORD dwLicenseMaskLast; // 0x98A4 sz:0x4
	DWORD dwModifiedMetadataOffset; // 0x98A8 sz:0x4
} XCONTENT_MOUNTED_PACKAGE, *PXCONTENT_MOUNTED_PACKAGE; // size 39084
C_ASSERT(sizeof(XCONTENT_MOUNTED_PACKAGE) == 0x98AC);


#endif // __XAMEXT_XCONTENT_H
